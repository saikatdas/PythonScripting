Regular expressions are used to find patterns in text. That's it. The pattern might be something as simple as the word "dog" in this sentence:

Test Regex here: https://regex101.com/

Text - The quick brown fox jumps over the lazy dog.

Pattern- dog (Find dog in a sentence) 

Find all words in a sentence that contains the letter "o"

Pattern - \w*o\w*  (so \w means all letters between a-z and * means the resulting RE to match 0 or more repetitions of the preceding RE, as many repetitions as are possible. ab* will match ‘a’, ‘ab’, or ‘a’ followed by any number of ‘b’s.)

pattern: cat
string:  The cat was cut when it ran under the car.
matches:     ---

pattern: ca[rt]
string:  The cat was cut when it ran under the car.
             ---                               ----
Above will look for car and cat because rt is inside [] third bracket

Task - Jim, where Bill had had "had", had had "had had". "Had had" had been correct.
Match all had in the above paragraph
Pattern - Hh[ad]

Task - A bat, a cat, and a rat walked into a bar...
Match all the animals
Pattern - [bcr]at   or bat|cat|rat

#ESCAPE SEQUENCE
you can't match special characters
Task - You can't match [] using regex! You will regret this!
Do - Try to match third brackets i.e. []
Regex = \[\]

pattern: \\
string:  C:\Users\Tanja\Pictures\Dogs
matches:   ^     ^     ^        ^
t   t   t   t

Pattern: \\\[\\]
String: ...match this regex `\[\]` with a regex?

Pattern: \\[rtn] or \\r|\\t|\\n
String: `\r`, `\t`, and `\n` are all regex escape sequences.

Pattern: \\.
String: Hi Walmart is my grandson there his name is "\n \r \t".

Task: Match all dots
Pattern: [.] or try \.
String:War is Peace. Freedom is Slavery. Ignorance is Strength.

Character ranges work the way you might expect, given the example above.
Put the first and last letters you want to match in the square brackets, with a hyphen in between them. If you only want to match the letters a through m, for instance, you could do:
pattern: \\[a-m]
string:  `\n`, `\r`, `\t`, and `\f` are whitespace characters, `\.`, `\\` and `\[` are not.
matches:

Hexadecimal numbers can contain digits 0-9 as well as letters A-F.
When used to specify colours, "hex" codes can be as short as three characters.
Create a regex to find valid hex codes in the list below:

Pattern: [A-F0-9]{3}|[0-9]{3} or try this- [0-9A-F][0-9A-F][0-9A-F]
String :  1H8 4E2 8FF 0P1 T8B 776 42B G12

Using character ranges, create a regex that will select only the
lowercase consonants (non-vowel characters, including y)
in the sentence below:

pattern:  [b-df-hj-np-tv-z] or [^aeiou]
string:  The walls in the mall are totally, totally tall.

pattern: [^aeiou .,T]
string:  The walls in the mall are totally, totally tall.

find all the years between 1977 and 1982 (inclusive) below:
pattern: 19[78][^3-6]
string:  1975 1976 1977 1978 1979 1980 1981 1982 1983 1984

Write a regex to match all characters below that aren't a literal carat ^ character:

pattern: [^\\^] or [^^]
string:  abc1^23*()

class	characters
\d	"digits" [0-9]
\w	"word characters" [A-Za-z0-9_]
\s	"whitespace" [ \t\r\n\f]

pattern: \\[a-z] or \\\w
string:  `\n`, `\r`, `\t`, and `\f` are whitespace characters, `\.


must start with a letter a-zA-Z, a dollar sign $, or an underscore _.
The remainder of the characters must be word characters \w.

Pattern: [a-zA-Z_$]\w{2}
String: __e $12 .x2 foo Bar 3mm


United States Social Security Numbers (SSNs) are 9-digit numbers in the format XXX-XX-XXXX,
where each X can be any digit [0-9]. Using one or more character classes,
write a regex to find the properly-formatted SSNs in the list below:

pattern: \d{3}-\d{2}-\d{4}
string:  113-25=1902 182-82-0192 H23-_3-9982 1I1-O0-E38B


Match all of the English words in the passage below.
pattern: [a-z]+
string:  3 plus 3 is six but 4 plus three is 7

Select only decimal point data with KB,MB,GB,TB
Pattern: (\d+.)(\d)(KB|MB|GB|TB)
String: 11TB 13 14.4MB 22HB 9.9GB TB 0KB

Now select only int data with KB,MB,GB,TB
Pattern: (\d)(KB|MB|GB|TB)
String: 11TB 13 14.4MB 22HB 9.9GB TB 0KB

Now select decimal or int data with KB,MB,GB,TB
Pattern: (\d)(KB|MB|GB|TB)|(\d+.)(\d)(KB|MB|GB|TB) or we can simplify  (\d*.\d)(KB|MB|GB|TB)
Or (\d+\.*\d*)(KB|MB|GB|TB)  or (\d+\.*\d*)[KMGT]B or \d+\.*\d*[KMGT]B
String: 11TB 13 14.4MB 22HB 9.9GB TB 0KB

Pattern: \d+\.?\d*[KMGT]B
String: 1..3KB 5...GB ..6TB
lesson - ? matches the previous token between zero and one times,
as many times as possible, giving back as needed (greedy)
